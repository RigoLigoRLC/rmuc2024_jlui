
# JLUI
适用于 RoboMaster 高校类赛事嵌入式开发者的客户端 UI 库，由吉林大学 TARS_Go 战队提供。

该库在 RoboMaster 2024 超级对抗赛中被我队及一些附近大学的团队广泛使用。但该库的质量依然是绝对没有任何保证的，如 [license](LICENSE) 中所述。

该库在 MIT 许可证下分发。

# 移植

## 实现接口
用户应实现以下函数，它们将由 JLUI 调用，确保 JLUI 可以链接它们：

```c
int JLUI_MutexLock(void *mutex);
void JLUI_MutexUnlock(void *mutex);
void JLUI_SendData(const uint8_t *data, size_t len);
```

互斥锁用于保护内部状态，以防多个线程尝试更新图形元素。这意味着你应该避免在中断服务例程 (ISR) 中调用 JLUI API —— 警惕系统挂起并破坏实时系统。

你的 `JLUI_SendData` 实现应将指定数量的字节发送到连接裁判系统串口的串口。注意，JLUI 假定此函数会阻塞执行，直到传输完成，并且在函数返回后，`data` 指针指向的内存应视为无效。如果你需要异步传输，请复制数据缓冲区。

## 调用 API

### 初始化

在调用任何其他 JLUI API 之前，请在启动时调用此函数：

```c
void JLUI_SetSenderReceiverId(uint16_t senderId, uint16_t receiverId);
```

在此设置你自己的机器人 ID 和选手客户端 ID。这也会清除内部缓冲区。

使用此 API 来设置互斥锁对象。如果你确认不需要使用互斥锁，随便将它设为一个非 0 的指针。

```c
void JLUI_SetMutexObject(void *mutex);
```

### 定期发送

截至本文撰写时（串口协议附录 V1.6.3），机器人间通信包的传输频率已增加至 30Hz。API 仍然被称为 `JLUI_10HzTick`，因为它曾经是 10Hz 很长一段时间。总之，在你希望的频率下调用此函数，JLUI 将处理其余部分。

```c
void JLUI_10HzTick(void);
```

## 配置

`jlui.h` 中定义了一些宏，可能对你很有用。请阅读一下文档，能对它们有个大概了解。

### 总容量

```c
#define JLUI_TOTAL_COUNT 30
```

每个 UI 元素在 RAM 中占据 16 字节。JLUI 有一个能容纳*这么多*个UI元素的内部缓冲区。根据你的个人需要修改这个宏定义。

### 数据检查断言开关

```c
#define JLUI_ENABLE_ASSERT
```

注释掉这一行宏可以把所有的断言变为空操作。断言对于调试很有帮助，但某些情况下你可能需要在不开优化的情况下编译项目。关掉断言可以减少浪费的 CPU 时间。

# 用法

首先调用 `JLUI_SetSenderReceiverId` 进行初始化。在这个调用之前不要调用任何其他的 API！

然后初始化你的互斥锁。

然后启动一个任务定期调用 `JLUI_10HzTick`。

现在你可以用 `JLUI_Create*` 系列函数和 `JLUI_Delete` 函数创建和删除对象了。创建函数会返回一个 `Uiid` 类型的对象句柄，你可以利用它调用其他函数修改对象的属性。

请参阅 `jlui.h` 来对 API 获得一个全面的认识。

# 内部实现

JLUI 有一个能容纳所有可用对象的池子，这个大小由之前提到的宏决定。当你调用创建函数时，库会在池子里寻找一个没被占用的槽位，然后把你的图形对象塞进去。

每个槽位有一个标志位字段，它描述了库在下一 tick 到来之时对这些对象做些什么。例如，一个新创建的对象会将 `dirtyVisibility` 标志置为 1，这样 tick 函数就可以使用正确的命令让它显示在选手端上。任何（颜色，线宽，坐标等）修改都会将 `dirty` 标志置位，这样下一 tick 时就能将它们发送出去。

库使用循环调度策略来将对象更新到选手客户端。在每个 tick，它会从列表的开头开始扫描，并在达到一个包中 7 个对象的限制或所有“dirty”对象都被处理时停止。库处理过的每个对象将被复制到一个单独的传输缓冲区中（该缓冲区大小足够容纳最大的 UI 包），并调用 `JLUI_SendData` 函数。当函数返回时，tick 结束。

如果库已达到 7 个对象的限制，它将在上一个 tick 停止的偏移处重新开始，并再次使用相同的策略进行扫描。

如果存在“dirty”字符串对象，情况会变得复杂。因为字符串对象必须占用整个包，库将交替发送常规对象包和字符串包，以确保其他关键对象的实时刷新，方式类似于“一字符串，一常规，一字符串，一常规，……直到没有 dirty 字符串对象”。字符串对象的扫描也是类似的“循环”方式。每当库决定发送一个字符串对象时，它会扫描整个池以找到一个字符串对象并完成，下一次从上次离开的地方重新开始。

# 优化

- 不要频繁修改字符串对象。使用其他对象来覆盖它们。这是个**非常非常非常**有用的技巧！
- 尽量将每 tick 需要更改的对象总数减少到 7 个或更少。

# 未完成的功能

- 清除所有对象有一个特殊的包，在 JLUI 中尚未实现。当尝试删除所有对象时，实际上是逐个删除对象。
- 有时链接可能会出现不稳定，创建对象的包可能没有到达服务器，因此一些对象可能会因此消失。一个可以解决此问题的方法是实现 `JLUI_RecreateAllObjects` 函数，该函数为每个对象发送创建包，但目前还未着手处理。

# 其他

中文版文档由 ChatGPT 从英文版翻译，RigoLigo 粗校对得到。如有其他问题请在 issue 联系。
